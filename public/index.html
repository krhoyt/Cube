<html>
<head>

<title>Rubik's Cube Solver</title>

<style>
body {
  background-color: #f5f5f5;
} 

video {
  display: none;
}

#camera {
  position: relative;
}

#camera > canvas {
  position: absolute;
}

#camera > svg {
  position: absolute;
}

.template {
  display: none;
}
</style>

</head>
<body>

<div id="camera">

  <!-- Rendering surface -->
  <canvas width="640" height="480"></canvas>

  <!-- Modes -->
  <svg width="640" height="480">
    <defs>
      <!-- Masking -->
      <!-- 2x2x2 -->
      <mask id="two">
        <rect x="0" y="0" width="640" height="480" fill="white"></rect>        
        <rect x="182" y="102" width="130" height="130" rx="6" fill="black"></rect>
        <rect x="182" y="247" width="130" height="130" rx="6" fill="black"></rect>              
        <rect x="327" y="102" width="130" height="130" rx="6" fill="black"></rect>
        <rect x="327" y="247" width="130" height="130" rx="6" fill="black"></rect>      
      </mask>

      <!-- 3x3x3 -->
      <mask id="three">
        <rect x="0" y="0" width="640" height="480" fill="white"></rect>        
        <rect x="95" y="15" width="130" height="130" rx="6" fill="black"></rect>
        <rect x="95" y="175" width="130" height="130" rx="6" fill="black"></rect>      
        <rect x="95" y="335" width="130" height="130" rx="6" fill="black"></rect>
        <rect x="255" y="15" width="130" height="130" rx="6" fill="black"></rect>
        <rect x="255" y="175" width="130" height="130" rx="6" fill="black"></rect>      
        <rect x="255" y="335" width="130" height="130" rx="6" fill="black"></rect>                  
        <rect x="415" y="15" width="130" height="130" rx="6" fill="black"></rect>
        <rect x="415" y="175" width="130" height="130" rx="6" fill="black"></rect>      
        <rect x="415" y="335" width="130" height="130" rx="6" fill="black"></rect>
      </mask>      
    </defs>

    <!-- Apply -->
    <rect x="0" y="0" width="640" height="480" fill="rgba( 0, 0, 0, 0.20 )" style="mask: url( #three );"></rect>
  </svg>

</div>

<!-- Web camera -->
<!-- Not visible -->
<video width="640" height="480"></video>

<!-- Face template -->
<svg class="face template" width="93" height="93">
  <!-- Row -->
  <rect width="31" height="31" rx="4"></rect> 
  <rect class="cubies" x="2" y="2" width="27" height="27" rx="2" fill="lightgrey"></rect>
  <rect x="31" width="31" height="31" rx="4"></rect> 
  <rect class="cubies" x="33" y="2" width="27" height="27" rx="2" fill="lightgrey"></rect>  
  <rect x="62" width="31" height="31" rx="4"></rect> 
  <rect class="cubies" x="64" y="2" width="27" height="27" rx="2" fill="lightgrey"></rect>

  <!-- Row -->
  <rect y="30" width="31" height="31" rx="4"></rect> 
  <rect class="cubies" x="2" y="32" width="27" height="27" rx="2" fill="lightgrey"></rect>
  <rect x="31" y="30" width="31" height="31" rx="4"></rect> 
  <rect class="side" x="33" y="32" width="27" height="27" rx="2" fill="green"></rect>  
  <rect x="62" y="30" width="31" height="31" rx="4"></rect> 
  <rect class="cubies" x="64" y="32" width="27" height="27" rx="2" fill="lightgrey"></rect>    

  <!-- Row -->
  <rect y="60" width="31" height="31" rx="4"></rect> 
  <rect class="cubies" x="2" y="62" width="27" height="27" rx="2" fill="lightgrey"></rect>
  <rect x="31" y="60" width="31" height="31" rx="4"></rect> 
  <rect class="cubies" x="33" y="62" width="27" height="27" rx="2" fill="lightgrey"></rect>  
  <rect x="62" y="60" width="31" height="31" rx="4"></rect> 
  <rect class="cubies" x="64" y="62" width="27" height="27" rx="2" fill="lightgrey"></rect>      
</svg>

<script src="../lib/mrdoob/three.js"></script>
<script src="../lib/mrdoob/OrbitControls.js"></script>

<script>
class Cube {
  constructor( interactive = true ) {
    this.cubies = [];
    this.palette = [0x008000, 0xff0000, 0x0000ff, 0xffa500, 0xffffff, 0xffff00];

    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color( 0xf5f5f5 );    
    
    this.camera = new THREE.PerspectiveCamera( 75, Cube.WIDTH / Cube.HEIGHT, 0.1, 1000 );
    this.camera.position.z = 3;    
    this.camera.position.x = 2.5;    
    this.camera.position.y = 2.25;        
    this.camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );        

    this.renderer = new THREE.WebGLRenderer( {antialias: true} );
    this.renderer.setSize( Cube.WIDTH, Cube.HEIGHT );
    
    document.body.appendChild( this.renderer.domElement );

    if( interactive ) {
      this.controls = new THREE.OrbitControls( this.camera );
    }

    // Center
    // Pivot
    // Used for side rotation
    this.pivot = new THREE.Mesh( 
      new THREE.SphereGeometry( 0.5 ),
      new THREE.MeshBasicMaterial( {
        color: 0xff00ff
      } ) 
    );
    this.scene.add( this.pivot );

    // Build and rotate sides
    for( let s = 0; s < this.palette.length; s++ ) {
      this.build( this.palette[s] );

      this.pivot.rotation.set( 0, 0, 0 );
      this.pivot.updateMatrixWorld();

      for( let c = 0; c < 9; c++ ) {
        this.cubies[( s * 9 ) + c].updateMatrixWorld();
        THREE.SceneUtils.attach( this.cubies[( s * 9 ) + c], this.scene, this.pivot );        
      }

      if( s < 4 ) {
        this.pivot.rotation.y = THREE.Math.degToRad( s * 90 );
      } else if( s == 4 ) {
        this.pivot.rotation.x = THREE.Math.degToRad( -90 );        
      } else if( s == 5 ) {
        this.pivot.rotation.x = THREE.Math.degToRad( 90 );                
      }

      this.pivot.updateMatrixWorld();      

      for( let c = 0; c < 9; c++ ) {
        THREE.SceneUtils.detach( this.cubies[( s * 9 ) + c], this.pivot, this.scene );        
      }      
    }

    /*
    // This works
    this.cubies[13].updateMatrixWorld();
    THREE.SceneUtils.attach( this.cubies[13], this.scene, this.pivot );

    this.pivot.rotation.y = THREE.Math.degToRad( 90 );
    this.pivot.updateMatrixWorld();

    THREE.SceneUtils.detach( this.cubies[13], this.pivot, this.scene );
    */

    this.render();
  }

  build( color = 0x00ff00 ) {    
    for( let y = 0; y < 3; y++ ) {
      for( let x = 0; x < 3; x++ ) {
        let cubie = new THREE.Mesh( 
          new THREE.BoxGeometry( 1, 1, 1 ),
          new THREE.MeshBasicMaterial( {
            color: 0x000000
        } ) );
        let sticker = new THREE.Mesh( 
          new THREE.BoxGeometry( 0.90, 0.90, 0.90 ),
          new THREE.MeshBasicMaterial( {
            color: ( x == 1 && y == 1 ) ? color : 0xd3d3d3
        } ) );        
        sticker.position.set( 0, 0, 0.1 );

        let group = new THREE.Group();        
        group.add( cubie );
        group.add( sticker );

        this.cubies.push( group );
        this.cubies[this.cubies.length - 1].position.set( x - 1, y - 1, 1 );        

        this.scene.add( this.cubies[this.cubies.length - 1] );        
      }
    }
  }

  render() {
    // this.cubies[13].rotation.x += 0.1;
    // this.cubies[13].rotation.y += 0.1;
    this.controls.update();    
    this.renderer.render( this.scene, this.camera );    
    requestAnimationFrame( () => { return this.render(); } );    
  }
}

Cube.WIDTH = 93;
Cube.HEIGHT = 93;

class Face {
  constructor( target, color = 'green' ) {
    this.palette = {
      R: 'red', G: 'green', B: 'blue', W: 'white', O: 'orange', Y: 'yellow',
      yellow: 'Y', orange: 'O', white: 'W', blue: 'B', green: 'G', red: 'R'
    };

    let template = document.querySelector( '.face.template' );

    this.root = template.cloneNode( true );
    this.root.classList.remove( 'template' );
    target.appendChild( this.root );

    this.side = this.root.querySelector( '.side' );
    this.side.setAttributeNS( null, 'fill', color );

    this.cubies = this.root.querySelectorAll( '.cubies' );
  }

  set colors( value ) {
    value = value.toUpperCase();

    for( let c = 0; c < this.cubies.length; c++ ) {
      this.cubies[c].setAttributeNS( null, 'fill', this.palette[value.charAt( c )] );
    }
  }

  get colors() {
    let result = '';

    for( let c = 0; c < this.cubies.length; c++ ) {
      if( c == 4 ) {
        result = result + this.palette[this.side.getAttributeNS( null, 'fill' )];
      }

      result = result + this.palette[this.cubies[c].getAttributeNS( null, 'fill' )];
    }

    return result;
  }
}

class Camera {
  constructor() {
    this.root = document.querySelector( '#camera' );
    
    this.canvas = this.root.querySelector( 'canvas' );
    this.context = this.canvas.getContext( '2d' );

    this.mode = this.root.querySelector( 'svg > rect' );

    this.video = document.querySelector( 'video' );

    /*
    navigator.mediaDevices.getUserMedia( {audio: false, video: true} )
      .then( ( stream ) => {
        // Set video to web camera
        this.video.srcObject = stream;
        
        // Wait for stream to start
        this.video.onloadedmetadata = function( evt ) {
          // Play the web camera video
          this.video.play();

          // Render to canvas
          this.render();
        }.bind( this );
      } ).catch( ( error ) => {
        console.log( error );
      } );
    */
  }

  render() {
    this.context.drawImage( this.video, 0, 0 );
    requestAnimationFrame( () => { return this.render(); } );        
  }  
}

class Solver {
  constructor() {
    this.camera = new Camera();
    this.cube = new Cube();
    this.faces = [
      new Face( document.body, 'green' ),
      new Face( document.body, 'red' ),
      new Face( document.body, 'blue' ),
      new Face( document.body, 'orange' ),
      new Face( document.body, 'white' ),
      new Face( document.body, 'yellow' )
    ];
    this.faces[0].colors = 'ROYGBWRO';
    console.log( this.faces[0].colors );
  }
}

// Application
let app = new Solver();
</script>

</body>
</html>
