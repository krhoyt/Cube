<html>
<head>

<title>Rubik's Cube Solver</title>

<style>
body {
  background-color: #f5f5f5;
} 

video {
  display: none;
}

#camera {
  position: relative;
}

#camera > canvas {
  position: absolute;
}

#camera > svg {
  position: absolute;
}

.template {
  display: none;
}
</style>

</head>
<body>

<div id="camera">

  <!-- Rendering surface -->
  <canvas width="640" height="480"></canvas>

  <!-- Modes -->
  <svg width="640" height="480">
    <defs>
      <!-- Masking -->
      <!-- 2x2x2 -->
      <mask id="two">
        <rect x="0" y="0" width="640" height="480" fill="white"></rect>        
        <rect x="182" y="102" width="130" height="130" rx="6" fill="black"></rect>
        <rect x="182" y="247" width="130" height="130" rx="6" fill="black"></rect>              
        <rect x="327" y="102" width="130" height="130" rx="6" fill="black"></rect>
        <rect x="327" y="247" width="130" height="130" rx="6" fill="black"></rect>      
      </mask>

      <!-- 3x3x3 -->
      <mask id="three">
        <rect x="0" y="0" width="640" height="480" fill="white"></rect>        
        <rect x="95" y="15" width="130" height="130" rx="6" fill="black"></rect>
        <rect x="95" y="175" width="130" height="130" rx="6" fill="black"></rect>      
        <rect x="95" y="335" width="130" height="130" rx="6" fill="black"></rect>
        <rect x="255" y="15" width="130" height="130" rx="6" fill="black"></rect>
        <rect x="255" y="175" width="130" height="130" rx="6" fill="black"></rect>      
        <rect x="255" y="335" width="130" height="130" rx="6" fill="black"></rect>                  
        <rect x="415" y="15" width="130" height="130" rx="6" fill="black"></rect>
        <rect x="415" y="175" width="130" height="130" rx="6" fill="black"></rect>      
        <rect x="415" y="335" width="130" height="130" rx="6" fill="black"></rect>
      </mask>      
    </defs>

    <!-- Apply -->
    <rect x="0" y="0" width="640" height="480" fill="rgba( 0, 0, 0, 0.20 )" style="mask: url( #three );"></rect>
  </svg>

</div>

<!-- Web camera -->
<!-- Not visible -->
<video width="640" height="480"></video>

<!-- Face template -->
<svg class="face template" width="93" height="93">
  <!-- Row -->
  <rect width="31" height="31" rx="4"></rect> 
  <rect class="cubies" x="2" y="2" width="27" height="27" rx="2" fill="lightgrey"></rect>
  <rect x="31" width="31" height="31" rx="4"></rect> 
  <rect class="cubies" x="33" y="2" width="27" height="27" rx="2" fill="lightgrey"></rect>  
  <rect x="62" width="31" height="31" rx="4"></rect> 
  <rect class="cubies" x="64" y="2" width="27" height="27" rx="2" fill="lightgrey"></rect>

  <!-- Row -->
  <rect y="30" width="31" height="31" rx="4"></rect> 
  <rect class="cubies" x="2" y="32" width="27" height="27" rx="2" fill="lightgrey"></rect>
  <rect x="31" y="30" width="31" height="31" rx="4"></rect> 
  <rect class="side cubies" x="33" y="32" width="27" height="27" rx="2" fill="green"></rect>  
  <rect x="62" y="30" width="31" height="31" rx="4"></rect> 
  <rect class="cubies" x="64" y="32" width="27" height="27" rx="2" fill="lightgrey"></rect>    

  <!-- Row -->
  <rect y="60" width="31" height="31" rx="4"></rect> 
  <rect class="cubies" x="2" y="62" width="27" height="27" rx="2" fill="lightgrey"></rect>
  <rect x="31" y="60" width="31" height="31" rx="4"></rect> 
  <rect class="cubies" x="33" y="62" width="27" height="27" rx="2" fill="lightgrey"></rect>  
  <rect x="62" y="60" width="31" height="31" rx="4"></rect> 
  <rect class="cubies" x="64" y="62" width="27" height="27" rx="2" fill="lightgrey"></rect>      
</svg>

<!-- ThreeJS -->
<script src="../lib/mrdoob/three.js"></script>
<script src="../lib/mrdoob/OrbitControls.js"></script>

<!-- TweenMax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.3/TweenMax.min.js"></script>

<script>
class Cube {
  constructor( interactive = true ) {
    this.cubies = [];
    this.side = 0;

    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color( 0xf5f5f5 );    
    
    this.camera = new THREE.PerspectiveCamera( 75, Cube.WIDTH / Cube.HEIGHT, 0.1, 1000 );
    this.camera.position.z = 3.75;    
    // this.camera.position.y = 2;        
    this.camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );        

    this.renderer = new THREE.WebGLRenderer( {antialias: true} );
    this.renderer.setSize( Cube.WIDTH, Cube.HEIGHT );
    
    document.body.appendChild( this.renderer.domElement );

    if( interactive ) {
      this.controls = new THREE.OrbitControls( this.camera );
    }

    // Center
    // Pivot
    // Used for side rotation
    this.pivot = new THREE.Mesh( 
      new THREE.SphereGeometry( 0.5 ),
      new THREE.MeshBasicMaterial( {
        color: 0xff00ff
      } ) 
    );
    this.scene.add( this.pivot );

    // Build and rotate sides
    // Move by association with tertiary object
    for( let side in Palette.sides ) {
      // Side
      this.build( Palette.sides[side].hex );

      // Center 
      this.pivot.rotation.set( 0, 0, 0 );
      this.pivot.updateMatrixWorld();

      // Move from scene to center
      for( let c = 0; c < 9; c++ ) {
        this.cubies[( this.side * 9 ) + c].updateMatrixWorld();
        THREE.SceneUtils.attach( this.cubies[( this.side * 9 ) + c], this.scene, this.pivot );        
      }

      // Rotate center
      // Place side in basic orientation
      if( this.side < 4 ) {
        this.pivot.rotation.y = THREE.Math.degToRad( this.side * 90 );
      } else if( this.side == 4 ) {
        this.pivot.rotation.x = THREE.Math.degToRad( -90 );        
      } else if( this.side == 5 ) {
        this.pivot.rotation.x = THREE.Math.degToRad( 90 );                
      }

      // Update matrix
      this.pivot.updateMatrixWorld();      

      // Move from center to scene
      for( let c = 0; c < 9; c++ ) {
        THREE.SceneUtils.detach( this.cubies[( this.side * 9 ) + c], this.pivot, this.scene );        
      }      

      this.side = this.side + 1;
    }

    this.side = 0;

    console.log( this.cubies[0].position );
    console.log( this.cubies[9].position );    

    this.render();
  }

  build( color = 0x00ff00 ) {    
    for( let y = 1; y > -2; y-- ) {
      for( let x = -1; x < 2; x++ ) {
        let cubie = new THREE.Mesh( 
          new THREE.BoxGeometry( 
            Cube.CUBIE_DIMENSIONS, 
            Cube.CUBIE_DIMENSIONS, 
            Cube.CUBIE_DIMENSIONS 
          ),
          new THREE.MeshBasicMaterial( {
            color: Palette.background
        } ) );
        let sticker = new THREE.Mesh( 
          new THREE.BoxGeometry( 
            Cube.STICKER_DIMENSIONS, 
            Cube.STICKER_DIMENSIONS, 
            Cube.STICKER_DIMENSIONS 
          ),
          new THREE.MeshBasicMaterial( {
            color: ( x == 0 && y == 0 ) ? color : Palette.nuetral
        } ) );        
        sticker.position.set( 0, 0, 0.1 );

        let group = new THREE.Group();  
        group.add( cubie );
        group.add( sticker );

        this.cubies.push( group );
        this.cubies[this.cubies.length - 1].position.set( x, y, 1 );        

        this.scene.add( this.cubies[this.cubies.length - 1] );        
      }
    }
  }

  set all( value ) {
    value = value.toUpperCase();

    for( let c = 0; c < this.cubies.length; c++ ) {
      this.cubies[c].children[1].material.color.setHex( Palette.sides[value.charAt( c )].hex );
    }    
  }

  get all() {
    let result = '';

    for( let c = 0; c < this.cubies.length; c++ ) {
      for( let side in Palette.sides ) {
        if( Palette.sides[side].hex == this.cubies[( this.side * 9 ) + c].children[1].material.color.getHex() ) {
          result = result + Palette.sides[side].short;
          break;
        }
      }
    }

    return result;    
  }

  set colors( value ) {
    value = value.toUpperCase();

    for( let c = 0; c < 9; c++ ) {
      this.cubies[( this.side * 9 ) + c].children[1].material.color.setHex( Palette.sides[value.charAt( c )].hex );
    }
  }

  get colors() {
    let result = '';

    for( let c = 0; c < 9; c++ ) {
      for( let side in Palette.sides ) {
        if( Palette.sides[side].hex == this.cubies[( this.side * 9 ) + c].children[1].material.color.getHex() ) {
          result = result + Palette.sides[side].short;
          break;
        }
      }
    }

    return result;
  }  

  render() {
    // Orbit controls
    if( this.controls ) {
      this.controls.update();    
    }

    // Render scene
    this.renderer.render( this.scene, this.camera );    

    // Keep rendering
    requestAnimationFrame( () => { return this.render(); } );    
  }

  rotate( degrees = -90, axis = 'y', part = 0 ) {
    // Center 
    this.pivot.rotation.set( 0, 0, 0 );
    this.pivot.updateMatrixWorld();

    let group = [];

    if( part == 0 ) {
      group = this.cubies.slice( 0 );
    } else {
      // Find cubies that apply to desired turn
      for( let c = 0; c < this.cubies.length; c++ ) {
        if( Math.round( this.cubies[c].position[axis] ) == part ) {
          group.push( this.cubies[c] );
        }
      }
    }

    // Move from scene to pivot
    for( let g = 0; g < group.length; g++ ) {
      group[g].updateMatrixWorld();
      THREE.SceneUtils.attach( group[g], this.scene, this.pivot );            
    }

    // Animation details
    let animation = {
      onComplete: function( cubies, pivot, scene ) {
        // Update matrix
        pivot.updateMatrixWorld();      

        for( let c = 0; c < cubies.length; c++ ) {
          THREE.SceneUtils.detach( cubies[c], pivot, scene );        
        }    
      },
      onCompleteParams: [group, this.pivot, this.scene]
    };

    // Dynamic axis property
    animation[axis] = THREE.Math.degToRad( degrees );

    // Animate
    TweenMax.to( this.pivot.rotation, 1, animation );
  }
}

Cube.CUBIE_DIMENSIONS = 1;
Cube.STICKER_DIMENSIONS = 0.90;
Cube.WIDTH = 93;
Cube.HEIGHT = 93;

class Face {
  constructor( target, color = 'green' ) {
    let template = document.querySelector( '.face.template' );

    this.root = template.cloneNode( true );
    this.root.classList.remove( 'template' );
    target.appendChild( this.root );

    this.cubies = this.root.querySelectorAll( '.cubies' );
    this.cubies[4].setAttributeNS( null, 'full', color );
  }

  set colors( value ) {
    value = value.toUpperCase();

    for( let c = 0; c < value.length; c++ ) {
      this.cubies[c].setAttributeNS( null, 'fill', Palette.sides[value.charAt( c )].name );
    }
  }

  get colors() {
    let result = '';

    for( let c = 0; c < this.cubies.length; c++ ) {
      result = result + Palette.colors[this.cubies[c].getAttributeNS( null, 'fill' )];
    }

    return result;
  }
}

class Camera {
  constructor() {
    this.root = document.querySelector( '#camera' );
    
    this.canvas = this.root.querySelector( 'canvas' );
    this.context = this.canvas.getContext( '2d' );

    this.mode = this.root.querySelector( 'svg > rect' );

    this.video = document.querySelector( 'video' );

    /*
    navigator.mediaDevices.getUserMedia( {audio: false, video: true} )
      .then( ( stream ) => {
        // Set video to web camera
        this.video.srcObject = stream;
        
        // Wait for stream to start
        this.video.onloadedmetadata = function( evt ) {
          // Play the web camera video
          this.video.play();

          // Render to canvas
          this.render();
        }.bind( this );
      } ).catch( ( error ) => {
        console.log( error );
      } );
    */
  }

  render() {
    this.context.drawImage( this.video, 0, 0 );
    requestAnimationFrame( () => { return this.render(); } );        
  }  
}

Palette = {
  sides: {    
    G: {red: 0, green: 128, blue: 0, hex: 0x008000, l: 46, a: -51, b: 49, name: 'green', short: 'G', face: 'L'}, 
    R: {red: 255, green: 0, blue: 0, hex: 0xff0000, l: 53, a: 80, b: 67, name: 'red', short: 'R', face: 'R'},     
    B: {red: 0, green: 0, blue: 255, hex: 0x0000ff, l: 32, a: 79, b: -107, name: 'blue', short: 'B', face: 'B'}, 
    O: {red: 255, green: 165, blue: 0, hex: 0xffa500, l: 74, a: 23, b: 78, name: 'orange', short: 'O', face: 'L'},  
    W: {red: 255, green: 255, blue: 255, hex: 0xffffff, l: 100, a: 0, b: 0, name: 'white', short: 'W', face: 'U'}, 
    Y: {red: 255, green: 255, blue: 0, hex: 0xffff00, l: 97, a: -21, b: 94, name: 'yellow', short: 'Y', face: 'D'}
  },
  colors: {
    green: 'G',
    red: 'R',
    blue: 'B',
    orange: 'O',
    white: 'W',
    yellow: 'Y'
  },
  nuetral: 0xd3d3d3,
  background: 'black'
};

class Solver {
  constructor() {
    this.camera = new Camera();
    this.cube = new Cube();
    this.faces = [
      new Face( document.body, 'green' ),
      new Face( document.body, 'red' ),
      new Face( document.body, 'blue' ),
      new Face( document.body, 'orange' ),
      new Face( document.body, 'white' ),
      new Face( document.body, 'yellow' )
    ];

    let scramble = [
      'WYRBGBRBO',
      'BWBOROYYG',
      'OWYGBRRWO',
      'BRGYOYGBW',
      'ROWGWGOGW',
      'GRBWYOYRY'
    ];

    for( let s = 0; s < scramble.length; s++ ) {
      this.cube.side = s;
      this.cube.colors = scramble[s];

      this.faces[s].colors = scramble[s];
    }

    this.cube.side = 0;
    console.log( this.cube.colors );
    console.log( this.faces[0].colors );

    this.cube.all = 'WYRBGBRBOBWBOROYYGOWYGBRRWOBRGYOYGBWROWGWGOGWGRBWYOYRY';
    console.log( this.cube.colors );

    this.cube.rotate();
  }
}

// Application
let app = new Solver();
</script>

</body>
</html>
